# generated by fastapi-codegen:
#   filename:  spec.yaml
#   timestamp: 2025-09-18T07:03:56+00:00

from __future__ import annotations

from typing import List, Optional, Union
from slowapi import Limiter, _rate_limit_exceeded_handler
from slowapi.util import get_remote_address
from slowapi.errors import RateLimitExceeded

from fastapi import FastAPI, Depends, Header, HTTPException, Request
from pydantic import conint
from typing import Union, List, Optional
from backend.services.auth_service import auth_service, refresh_tokens, logout_user_tokens
from backend.services.SAN_test_service import SANTestService
from backend.firebase_app import RealtimeDB, verify_firebase_token, create_firebase_custom_token
from backend.utils.jwt_utils import generate_refresh_token
from backend.models import (
    LogoutRequest,
    AuthResponse,
    ChangeEmailRequest,
    ChangePasswordRequest,
    ChatMessage,
    ChatMessageRequest,
    EmotionAnalysisResponse,
    Error,
    LoginRequest,
    RegisterRequest,
    RefreshRequest,
    SuccessResponse,
    TestResult,
    TestResultRequest,
    UpdateProfileRequest,
    UserProfile,
    SanProcessRequest,
    SanProcessResponse,
)

from backend.services.ai_service import AIService
from backend.utils.time_utils import TimeAndSeasonData
import json
from fastapi.responses import StreamingResponse
from datetime import datetime

from datetime import datetime
from fastapi.middleware.cors import CORSMiddleware


app = FastAPI(
    title='Эмоции Гид API',
    description='API для веб-версии приложения по отслеживанию эмоционального состояния.\n\n## Общая информация\nAPI предоставляет функциональность для:\n- Аутентификации и управления пользователями\n- Отслеживания эмоционального состояния\n- Чат-бота с искусственным интеллектом\n- Аналитики и визуализации данных\n\n## Аутентификация\nВсе запросы к защищенным эндпоинтам требуют JWT токен в заголовке:\n```\nAuthorization: Bearer <token>\n```\n\n## Форматы данных\nВсе данные передаются в формате JSON.\n\n## Обработка ошибок\nВ случае ошибок API возвращает соответствующий HTTP статус код и объект с описанием ошибки.\n',
    version='1.0.0',
    contact={'email': 'dementjew.vania2016@yandex.ru'},
    servers=[
        {
            'url': 'https://api.emotion-guide.ru/v1',
            'description': 'Основной сервер API',
        }
    ],
)

app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

limiter = Limiter(key_func=get_remote_address)
app.state.limiter = limiter
app.add_exception_handler(RateLimitExceeded, _rate_limit_exceeded_handler)


san_service = SANTestService()
ai_service = AIService()

async def get_current_user_id(authorization: Optional[str] = Header(None)) -> str:
    """Dependency для получения user_id из Firebase токена."""
    if not authorization:
        raise HTTPException(status_code=401, detail="Authorization header missing")
    if not authorization.startswith("Bearer "):
        raise HTTPException(status_code=401, detail="Invalid authorization header")
    token = authorization.split(" ")[1]
    try:
        decoded = verify_firebase_token(token)
        import logging
        logger = logging.getLogger(__name__)
        logger.info(f"Decoded token uid: {decoded['uid']}")
        return decoded["uid"]
    except Exception as e:
        import logging
        logger = logging.getLogger(__name__)
        logger.error(f"Token verification error: {e}")
        raise HTTPException(status_code=401, detail="Invalid or expired token")


@app.post(
    '/api/auth/refresh',
    response_model=AuthResponse,
    responses={'400': {'model': Error}, '401': {'model': Error}},
    tags=['Аутентификация'],
)
def post_api_auth_refresh(body: RefreshRequest) -> Union[AuthResponse, Error]:
    """
    Обновление access токена по refresh токену
    """
    result = refresh_tokens(body.refreshToken)
    if not result['success']:
        raise HTTPException(status_code=400, detail=result['error'])
    data = result['data']
    # Получить email и username из DB
    user_data = RealtimeDB.get(f'Users/{data["userId"]}')
    return AuthResponse(
        userId=data['userId'],
        email=user_data.get('email') if user_data else None,
        username=user_data.get('username') if user_data else None,
        accessToken=data['accessToken'],
        refreshToken=data['refreshToken']
    )


@app.post(
    '/api/auth/login',
    response_model=AuthResponse,
    responses={'400': {'model': Error}, '401': {'model': Error}},
    tags=['Аутентификация'],
)
def post_api_auth_login(body: LoginRequest) -> Union[AuthResponse, Error]:
    """
    Вход в систему
    """
    result = auth_service.login(body.email, body.password)
    if not result['success']:
        raise HTTPException(status_code=400, detail=result['error'])
    data = result['data']
    # Адаптируем под модель: token = accessToken, добавить refresh
    return AuthResponse(
        userId=data['userId'],
        email=data['email'],
        username=data['username'],
        accessToken=data['accessToken'],
        refreshToken=data['refreshToken']
    )


@app.post(
    '/api/auth/logout',
    response_model=SuccessResponse,
    responses={'400': {'model': Error}, '401': {'model': Error}},
    tags=['Аутентификация'],
)
def post_api_auth_logout(body: LogoutRequest) -> Union[SuccessResponse, Error]:
    """
    Выход из аккаунта с инвалидацией refresh токена
    """
    result = logout_user_tokens(body.refreshToken)
    if not result['success']:
        raise HTTPException(status_code=400, detail=result['error'])
    return SuccessResponse(message=result['message'])


@app.post(
    '/api/auth/register',
    response_model=AuthResponse,
    responses={'400': {'model': Error}, '409': {'model': Error}},
    tags=['Аутентификация'],
)
def post_api_auth_register(body: RegisterRequest) -> Union[AuthResponse, Error]:
    """
    Регистрация нового пользователя
    """
    if not body.termsAccepted:
        raise HTTPException(status_code=400, detail="Terms must be accepted")
    result = auth_service.register(body.email, body.password, body.username, body.termsAccepted)
    if not result['success']:
        raise HTTPException(status_code=409 if "already exists" in result['error'].lower() else 400, detail=result['error'])
    data = result['data']
    return AuthResponse(
        userId=data['userId'],
        email=data['email'],
        username=data['username'],
        accessToken=data['accessToken'],
        refreshToken=generate_refresh_token(data['userId'])
    )


@app.post(
    '/api/chat/analyze-emotions',
    tags=['Чат', 'Аналитика'],
)
async def post_api_chat_analyze_emotions(user_id: str = Depends(get_current_user_id)):
    """
    Анализ результатов теста САН с ИИ (стриминг SSE).
    """
    from backend.services.SAN_test_service import SANTestService
    san_service = SANTestService()

    # Cooldown check
    metadata = RealtimeDB.get(f'Users/{user_id}/metadata') or {}
    last_analysis = metadata.get('last_analysis_time', 0)
    now = int(datetime.now().timestamp() * 1000)
    if now - last_analysis < 30000:
        raise HTTPException(status_code=429, detail="Cooldown: подождите 30 секунд")

    # Placeholder
    placeholder = {
        'content': '⌛ Пожалуйста, подождите...',
        'isUser': False,
        'timestamp': datetime.now().isoformat()
    }
    placeholder_key = RealtimeDB.create(f'Users/{user_id}/ChatMessages', placeholder)

    try:
        time_data_obj = TimeAndSeasonData()
        time_data = time_data_obj.get_time_data()
        results = RealtimeDB.get(f'Users/{user_id}/TestResults') or {}
        sorted_results = sorted(results.values(), key=lambda x: x.get('timestamp', 0), reverse=True)[:25]
        username = RealtimeDB.get(f'Users/{user_id}').get('username', 'Пользователь')

        json_data = san_service.prepare_san_data_for_ai(sorted_results, username, time_data)
        print("JSON data preview:", json_data[:500])  # Debug: preview data sent to AI
        print("Number of tests:", len(sorted_results))

        if not sorted_results:
            prompt = ai_service.results_empty_prompt.format(
                username=username,
                season=time_data['season'],
                time_of_day=time_data['timeOfDay'],
                suggestion="прогулку на свежем воздухе" if time_data['timeOfDay'] == "утро" else "чай перед сном"
            )
        else:
            prompt = ai_service.results_not_empty_prompt.format(
                username=username,
                time_of_day=time_data['timeOfDay'],
                season=time_data['season'],
                json_data=json_data
            )
            print("Prompt length:", len(prompt))  # Debug: prompt size
            print("Prompt preview:", prompt[:500])  # Debug: start of prompt

        async def generate_analysis():
            # Получить полный ответ без стриминга
            full_ai_generator = ai_service.send_request(prompt, "", stream=False)
            full_ai = ""
            async for content in full_ai_generator:
                full_ai += content
            # Update metadata
            RealtimeDB.update(f'Users/{user_id}/metadata', {'last_analysis_time': now})
            # Update placeholder with full
            filtered_full = ai_service._filter_response(full_ai)  # Assume access
            RealtimeDB.update(f'Users/{user_id}/ChatMessages/{placeholder_key}', {'content': filtered_full})
            # Limit 50
            all_msgs = RealtimeDB.get(f'Users/{user_id}/ChatMessages') or {}
            if len(all_msgs) > 50:
                sorted_keys = sorted(all_msgs.keys(), key=lambda k: all_msgs[k].get('timestamp', ''))[:len(all_msgs)-50]
                for old_key in sorted_keys:
                    RealtimeDB.delete(f'Users/{user_id}/ChatMessages/{old_key}')
            # Yield полный ответ сразу
            yield f"data: {json.dumps({'type': 'done', 'content': filtered_full, 'prompt': prompt})}\n\n"

        return StreamingResponse(generate_analysis(), media_type="text/event-stream")

    except Exception as e:
        RealtimeDB.delete(f'Users/{user_id}/ChatMessages/{placeholder_key}')
        raise HTTPException(status_code=500, detail=str(e))


@app.post(
    '/api/chat/messages',
    tags=['Чат'],
)
async def post_api_chat_messages(body: ChatMessageRequest, user_id: str = Depends(get_current_user_id)):
    """
    Отправка сообщения пользователя в чат и получение AI ответа (стриминг SSE).
    """
    if not body.isUser:
        raise HTTPException(status_code=400, detail="Only user messages allowed")

    # Cooldown
    metadata = RealtimeDB.get(f'Users/{user_id}/metadata') or {}
    last_chat = metadata.get('last_chat_time', 0)
    now = int(datetime.now().timestamp() * 1000)
    if now - last_chat < 30000:
        raise HTTPException(status_code=429, detail="Cooldown: подождите 30 секунд")

    # Save user
    user_data = {
        'content': body.content,
        'isUser': True,
        'timestamp': datetime.now().isoformat()
    }
    user_key = RealtimeDB.create(f'Users/{user_id}/ChatMessages', user_data)

    # Placeholder AI
    placeholder_data = {
        'content': '⌛ Пожалуйста, подождите...',
        'isUser': False,
        'timestamp': datetime.now().isoformat()
    }
    placeholder_key = RealtimeDB.create(f'Users/{user_id}/ChatMessages', placeholder_data)

    try:
        # History last 10
        all_msgs = RealtimeDB.get(f'Users/{user_id}/ChatMessages') or {}
        sorted_msgs = sorted(all_msgs.values(), key=lambda x: x.get('timestamp', ''), reverse=True)[:10]
        history = [{"role": "user" if m.get('isUser') else "assistant", "content": m.get('content', '')} for m in reversed(sorted_msgs)]

        # Prompt
        history_str = "\n".join([f"{h['role'].capitalize()}: {h['content']}" for h in history])
        prompt = f"{ai_service.system_prompt_chat}\n\nПредыдущий разговор:\n{history_str}"

        async def generate_chat():
            full_ai = ""
            async for chunk in ai_service.send_request(prompt, body.content, history, stream=True):
                full_ai += chunk
                yield f"data: {json.dumps({'type': 'chunk', 'content': chunk})}\n\n"
            # Update
            RealtimeDB.update(f'Users/{user_id}/metadata', {'last_chat_time': now})
            filtered_full = ai_service._filter_response(full_ai)
            RealtimeDB.update(f'Users/{user_id}/ChatMessages/{placeholder_key}', {'content': filtered_full})
            # Limit 50
            all_msgs = RealtimeDB.get(f'Users/{user_id}/ChatMessages') or {}
            if len(all_msgs) > 50:
                sorted_keys = sorted(all_msgs.keys(), key=lambda k: all_msgs[k].get('timestamp', ''))[:len(all_msgs)-50]
                for old_key in sorted_keys:
                    RealtimeDB.delete(f'Users/{user_id}/ChatMessages/{old_key}')
            yield f"data: {json.dumps({'type': 'done', 'content': filtered_full})}\n\n"

        return StreamingResponse(generate_chat(), media_type="text/event-stream")

    except Exception as e:
        RealtimeDB.delete(f'Users/{user_id}/ChatMessages/{placeholder_key}')
        raise HTTPException(status_code=500, detail=str(e))


@app.get(
    '/api/chat/messages',
    response_model=List[ChatMessage],
    responses={'401': {'model': Error}},
    tags=['Чат'],
)
def get_api_chat_messages(
    limit: Optional[conint(ge=1, le=100)] = 20,
    user_id: str = Depends(get_current_user_id)
) -> Union[List[ChatMessage], Error]:
    """
    Получение истории сообщений
    """
    messages = RealtimeDB.get(f'Users/{user_id}/ChatMessages')
    if not messages:
        return []
    # Сортировка по timestamp, limit последних
    sorted_msgs = sorted(messages.values(), key=lambda x: x.get('timestamp', ''), reverse=True)[:limit]
    return [ChatMessage(**msg) for msg in sorted_msgs]


@app.get(
    '/api/san/questions',
    response_model=List[dict],
    responses={'401': {'model': Error}},
    tags=['Тесты'],
)
def get_api_san_questions(user_id: str = Depends(get_current_user_id)) -> List[Dict]:
    """
    Получение списка вопросов для теста САН
    """
    return san_service.get_questions()


@app.post(
    '/api/san/process',
    response_model=SanProcessResponse,
    responses={'400': {'model': Error}, '401': {'model': Error}},
    tags=['Тесты'],
)
def post_api_san_process(body: SanProcessRequest, user_id: str = Depends(get_current_user_id)) -> Union[SanProcessResponse, Error]:
    """
    Обработка ответов САН и возврат баллов с интерпретацией (сохраняет в DB)
    """
    result = san_service.process_answers(body.answers)
    # Автоматически сохранить
    success = san_service.save_result(user_id, result['wellbeing'], result['activity'], result['mood'])
    if not success:
        raise HTTPException(status_code=500, detail="Failed to save result")
    return SanProcessResponse(
        wellbeing=result['wellbeing'],
        activity=result['activity'],
        mood=result['mood'],
        timestamp=result['timestamp'],
        interpretation=result['interpretation']
    )


@app.post(
    '/api/test-results',
    response_model=SuccessResponse,
    responses={'400': {'model': Error}, '401': {'model': Error}},
    tags=['Тесты'],
)
def post_api_test_results(body: TestResultRequest, user_id: str = Depends(get_current_user_id)) -> Union[SuccessResponse, Error]:
    """
    Сохранение готового результата теста САН (альтернатива process)
    """
    # Преобразовать int в float
    wellbeing = float(body.wellbeingScore)
    activity = float(body.activityScore)
    mood = float(body.moodScore)
    success = san_service.save_result(user_id, wellbeing, activity, mood)
    if not success:
        raise HTTPException(status_code=500, detail="Failed to save result")
    return SuccessResponse(message="Test result saved")


@app.get(
    '/api/test-results',
    response_model=List[TestResult],
    responses={'401': {'model': Error}},
    tags=['Тесты'],
)
def get_api_test_results(
    limit: Optional[conint(ge=1, le=50)] = 5,
    user_id: str = Depends(get_current_user_id)
) -> Union[List[TestResult], Error]:
    """
    Получение последних результатов тестов
    """
    results = RealtimeDB.get(f'Users/{user_id}/TestResults')
    if not results:
        return []
    # Сортировка по timestamp, limit последних
    sorted_results = sorted(results.values(), key=lambda x: x.get('timestamp', 0), reverse=True)[:limit]
    test_results = []
    for res in sorted_results:
        test_results.append(TestResult(
            resultId=str(hash(str(res))),  # Pseudo ID
            userId=user_id,
            wellbeingScore=int(res.get('wellbeingScore', 0)),
            activityScore=int(res.get('activityScore', 0)),
            moodScore=int(res.get('moodScore', 0)),
            timestamp=datetime.fromtimestamp(res.get('timestamp', 0) / 1000) if res.get('timestamp') else None
        ))
    return test_results


@app.delete(
    '/api/test-results',
    response_model=SuccessResponse,
    responses={'401': {'model': Error}},
    tags=['Тесты'],
)
def delete_api_test_results(user_id: str = Depends(get_current_user_id)) -> Union[SuccessResponse, Error]:
    """
    Сброс всех результатов тестов
    """
    RealtimeDB.delete(f'Users/{user_id}/TestResults')
    return SuccessResponse(message="All test results deleted")


@app.put(
    '/api/users/change-email',
    response_model=SuccessResponse,
    responses={
        '400': {'model': Error},
        '401': {'model': Error},
        '409': {'model': Error},
    },
    tags=['Пользователи'],
)
def put_api_users_change_email(
    body: ChangeEmailRequest,
    user_id: str = Depends(get_current_user_id)
) -> Union[SuccessResponse, Error]:
    """
    Смена email пользователя
    """
    # Заглушка: Firebase Auth change email требует password verify, но сервис не имеет
    # В реальности: auth.update_user(user_id, email=body.newEmail)
    # Здесь просто update в DB
    RealtimeDB.update(f'Users/{user_id}', {'email': body.newEmail})
    return SuccessResponse(message="Email changed successfully")


@app.put(
    '/api/users/change-password',
    response_model=SuccessResponse,
    responses={'400': {'model': Error}, '401': {'model': Error}},
    tags=['Пользователи'],
)
def put_api_users_change_password(
    body: ChangePasswordRequest,
    user_id: str = Depends(get_current_user_id)
) -> Union[SuccessResponse, Error]:
    """
    Смена пароля пользователя
    """
    # Заглушка: Firebase Auth update_password, но требует current password verify
    # auth.update_user(user_id, password=body.newPassword)
    return SuccessResponse(message="Password changed successfully")


@app.get(
    '/api/users/profile',
    response_model=UserProfile,
    responses={'401': {'model': Error}},
    tags=['Пользователи'],
)
def get_api_users_profile(user_id: str = Depends(get_current_user_id)) -> Union[UserProfile, Error]:
    """
    Получение профиля пользователя
    """
    import logging
    logger = logging.getLogger(__name__)
    profile = RealtimeDB.get(f'Users/{user_id}')
    logger.info(f"DB query for user_id {user_id}: {profile}")
    if not profile:
        raise HTTPException(status_code=404, detail="Profile not found")
    return UserProfile(
        userId=user_id,
        email=profile.get('email'),
        username=profile.get('username'),
        createdAt=datetime.fromisoformat(profile.get('createdAt')) if profile.get('createdAt') else None,
        updatedAt=datetime.now()  # Pseudo
    )


@app.put(
    '/api/users/profile',
    response_model=UserProfile,
    responses={'400': {'model': Error}, '401': {'model': Error}},
    tags=['Пользователи'],
)
def put_api_users_profile(body: UpdateProfileRequest, user_id: str = Depends(get_current_user_id)) -> Union[UserProfile, Error]:
    """
    Обновление профиля пользователя
    """
    if body.username:
        RealtimeDB.update(f'Users/{user_id}', {'username': body.username, 'updatedAt': datetime.now().isoformat()})
    # Fetch updated
    profile = RealtimeDB.get(f'Users/{user_id}')
    return UserProfile(
        userId=user_id,
        email=profile.get('email'),
        username=profile.get('username'),
        createdAt=datetime.fromisoformat(profile.get('createdAt')) if profile.get('createdAt') else None,
        updatedAt=datetime.fromisoformat(profile.get('updatedAt')) if profile.get('updatedAt') else None
    )


@app.delete(
    '/api/chat/history',
    response_model=SuccessResponse,
    responses={'401': {'model': Error}},
    tags=['Чат'],
)
def delete_api_chat_history(user_id: str = Depends(get_current_user_id)) -> Union[SuccessResponse, Error]:
    """
    Очистка истории чата.
    """
    RealtimeDB.delete(f'Users/{user_id}/ChatMessages')
    welcome = {
        'content': 'Здравствуйте! Я ваш ИИ-психолог. Расскажите, как дела?',
        'isUser': False,
        'timestamp': datetime.now().isoformat()
    }
    RealtimeDB.create(f'Users/{user_id}/ChatMessages', welcome)
    return SuccessResponse(message="История очищена")


@app.get(
    '/api/chat/metadata',
    response_model=dict,
    responses={'401': {'model': Error}},
    tags=['Чат'],
)
def get_api_chat_metadata(user_id: str = Depends(get_current_user_id)) -> dict:
    """
    Метаданные чата для cooldown.
    """
    metadata = RealtimeDB.get(f'Users/{user_id}/metadata') or {}
    now = int(datetime.now().timestamp() * 1000)
    return {
        "last_chat_time": metadata.get('last_chat_time', 0),
        "chat_cooldown_remaining": max(0, 30000 - (now - metadata.get('last_chat_time', 0))),
        "last_analysis_time": metadata.get('last_analysis_time', 0),
        "analysis_cooldown_remaining": max(0, 30000 - (now - metadata.get('last_analysis_time', 0)))
    }
