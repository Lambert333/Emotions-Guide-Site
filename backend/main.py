# generated by fastapi-codegen:
#   filename:  spec.yaml
#   timestamp: 2025-09-18T07:03:56+00:00

from __future__ import annotations

from typing import List, Optional, Union
from slowapi import Limiter, _rate_limit_exceeded_handler
from slowapi.util import get_remote_address
from slowapi.errors import RateLimitExceeded

from fastapi import FastAPI, Depends, Header, HTTPException, Request
from pydantic import conint
from typing import Union, List, Optional
from backend.services.auth_service import auth_service, refresh_tokens, logout_user_tokens
from backend.services.SAN_test_service import SANTestService
from backend.firebase_app import RealtimeDB, verify_firebase_token, create_firebase_custom_token
from backend.utils.jwt_utils import generate_refresh_token
from backend.models import (
    LogoutRequest,
    AuthResponse,
    ChangeEmailRequest,
    ChangePasswordRequest,
    ChatMessage,
    ChatMessageRequest,
    EmotionAnalysisResponse,
    Error,
    LoginRequest,
    RegisterRequest,
    RefreshRequest,
    SuccessResponse,
    TestResult,
    TestResultRequest,
    UpdateProfileRequest,
    UserProfile,
    SanProcessRequest,
    SanProcessResponse,
)

from datetime import datetime


app = FastAPI(
    title='Эмоции Гид API',
    description='API для веб-версии приложения по отслеживанию эмоционального состояния.\n\n## Общая информация\nAPI предоставляет функциональность для:\n- Аутентификации и управления пользователями\n- Отслеживания эмоционального состояния\n- Чат-бота с искусственным интеллектом\n- Аналитики и визуализации данных\n\n## Аутентификация\nВсе запросы к защищенным эндпоинтам требуют JWT токен в заголовке:\n```\nAuthorization: Bearer <token>\n```\n\n## Форматы данных\nВсе данные передаются в формате JSON.\n\n## Обработка ошибок\nВ случае ошибок API возвращает соответствующий HTTP статус код и объект с описанием ошибки.\n',
    version='1.0.0',
    contact={'email': 'dementjew.vania2016@yandex.ru'},
    servers=[
        {
            'url': 'https://api.emotion-guide.com/v1',
            'description': 'Основной сервер API',
        }
    ],
)

limiter = Limiter(key_func=get_remote_address)
app.state.limiter = limiter
app.add_exception_handler(RateLimitExceeded, _rate_limit_exceeded_handler)


san_service = SANTestService()

async def get_current_user_id(authorization: Optional[str] = Header(None)) -> str:
    """Dependency для получения user_id из Firebase токена."""
    if not authorization:
        raise HTTPException(status_code=401, detail="Authorization header missing")
    if not authorization.startswith("Bearer "):
        raise HTTPException(status_code=401, detail="Invalid authorization header")
    token = authorization.split(" ")[1]
    try:
        decoded = verify_firebase_token(token)
        import logging
        logger = logging.getLogger(__name__)
        logger.info(f"Decoded token uid: {decoded['uid']}")
        return decoded["uid"]
    except Exception as e:
        import logging
        logger = logging.getLogger(__name__)
        logger.error(f"Token verification error: {e}")
        raise HTTPException(status_code=401, detail="Invalid or expired token")


@app.post(
    '/api/auth/refresh',
    response_model=AuthResponse,
    responses={'400': {'model': Error}, '401': {'model': Error}},
    tags=['Аутентификация'],
)
def post_api_auth_refresh(body: RefreshRequest) -> Union[AuthResponse, Error]:
    """
    Обновление access токена по refresh токену
    """
    result = refresh_tokens(body.refreshToken)
    if not result['success']:
        raise HTTPException(status_code=400, detail=result['error'])
    data = result['data']
    # Получить email и username из DB
    user_data = RealtimeDB.get(f'Users/{data["userId"]}')
    return AuthResponse(
        userId=data['userId'],
        email=user_data.get('email') if user_data else None,
        username=user_data.get('username') if user_data else None,
        accessToken=data['accessToken'],
        refreshToken=data['refreshToken']
    )


@app.post(
    '/api/auth/login',
    response_model=AuthResponse,
    responses={'400': {'model': Error}, '401': {'model': Error}},
    tags=['Аутентификация'],
)
def post_api_auth_login(body: LoginRequest) -> Union[AuthResponse, Error]:
    """
    Вход в систему
    """
    result = auth_service.login(body.email, body.password)
    if not result['success']:
        raise HTTPException(status_code=400, detail=result['error'])
    data = result['data']
    # Адаптируем под модель: token = accessToken, добавить refresh
    return AuthResponse(
        userId=data['userId'],
        email=data['email'],
        username=data['username'],
        accessToken=data['accessToken'],
        refreshToken=data['refreshToken']
    )


@app.post(
    '/api/auth/logout',
    response_model=SuccessResponse,
    responses={'400': {'model': Error}, '401': {'model': Error}},
    tags=['Аутентификация'],
)
def post_api_auth_logout(body: LogoutRequest) -> Union[SuccessResponse, Error]:
    """
    Выход из аккаунта с инвалидацией refresh токена
    """
    result = logout_user_tokens(body.refreshToken)
    if not result['success']:
        raise HTTPException(status_code=400, detail=result['error'])
    return SuccessResponse(message=result['message'])


@app.post(
    '/api/auth/register',
    response_model=AuthResponse,
    responses={'400': {'model': Error}, '409': {'model': Error}},
    tags=['Аутентификация'],
)
def post_api_auth_register(body: RegisterRequest) -> Union[AuthResponse, Error]:
    """
    Регистрация нового пользователя
    """
    if not body.termsAccepted:
        raise HTTPException(status_code=400, detail="Terms must be accepted")
    result = auth_service.register(body.email, body.password, body.username, body.termsAccepted)
    if not result['success']:
        raise HTTPException(status_code=409 if "already exists" in result['error'].lower() else 400, detail=result['error'])
    data = result['data']
    return AuthResponse(
        userId=data['userId'],
        email=data['email'],
        username=data['username'],
        accessToken=data['accessToken'],
        refreshToken=generate_refresh_token(data['userId'])
    )


@app.post(
    '/api/chat/analyze-emotions',
    response_model=EmotionAnalysisResponse,
    responses={'401': {'model': Error}},
    tags=['Чат', 'Аналитика'],
)
def post_api_chat_analyze_emotions(user_id: str = Depends(get_current_user_id)) -> Union[EmotionAnalysisResponse, Error]:
    """
    Анализ эмоций по результатам тестов САН
    """
    # Заглушка: fetch последних результатов и анализ
    results = RealtimeDB.get(f'Users/{user_id}/TestResults')
    if not results:
        raise HTTPException(status_code=404, detail="No test results found")
    # Простой анализ (расширить позже)
    recent = list(results.values())[-1] if isinstance(results, dict) else results
    return EmotionAnalysisResponse(
        analysis=f"Анализ на основе последних тестов: wellbeingScore {recent.get('wellbeingScore', 0):.1f}, activityScore {recent.get('activityScore', 0):.1f}, moodScore {recent.get('moodScore', 0):.1f}.",
        recommendations=["Продолжайте мониторинг", "Увеличьте активность"],
        createdAt=datetime.now()
    )


@app.post(
    '/api/chat/messages',
    response_model=ChatMessage,
    responses={'400': {'model': Error}, '401': {'model': Error}},
    tags=['Чат'],
)
def post_api_chat_messages(body: ChatMessageRequest, user_id: str = Depends(get_current_user_id)) -> Union[ChatMessage, Error]:
    """
    Отправка сообщения в чат
    """
    # Заглушка: сохранить в DB /Users/{user_id}/ChatMessages/{push}
    message_data = {
        'content': body.content,
        'isUser': body.isUser,
        'timestamp': datetime.now().isoformat()
    }
    key = RealtimeDB.create(f'Users/{user_id}/ChatMessages', message_data)
    return ChatMessage(
        messageId=key,
        userId=user_id,
        content=body.content,
        isUser=body.isUser,
        timestamp=datetime.now()
    )


@app.get(
    '/api/chat/messages',
    response_model=List[ChatMessage],
    responses={'401': {'model': Error}},
    tags=['Чат'],
)
def get_api_chat_messages(
    limit: Optional[conint(ge=1, le=100)] = 20,
    user_id: str = Depends(get_current_user_id)
) -> Union[List[ChatMessage], Error]:
    """
    Получение истории сообщений
    """
    messages = RealtimeDB.get(f'Users/{user_id}/ChatMessages')
    if not messages:
        return []
    # Сортировка по timestamp, limit последних
    sorted_msgs = sorted(messages.values(), key=lambda x: x.get('timestamp', ''), reverse=True)[:limit]
    return [ChatMessage(**msg) for msg in sorted_msgs]


@app.get(
    '/api/san/questions',
    response_model=List[dict],
    responses={'401': {'model': Error}},
    tags=['Тесты'],
)
def get_api_san_questions(user_id: str = Depends(get_current_user_id)) -> List[Dict]:
    """
    Получение списка вопросов для теста САН
    """
    return san_service.get_questions()


@app.post(
    '/api/san/process',
    response_model=SanProcessResponse,
    responses={'400': {'model': Error}, '401': {'model': Error}},
    tags=['Тесты'],
)
def post_api_san_process(body: SanProcessRequest, user_id: str = Depends(get_current_user_id)) -> Union[SanProcessResponse, Error]:
    """
    Обработка ответов САН и возврат баллов с интерпретацией (сохраняет в DB)
    """
    result = san_service.process_answers(body.answers)
    # Автоматически сохранить
    success = san_service.save_result(user_id, result['wellbeing'], result['activity'], result['mood'])
    if not success:
        raise HTTPException(status_code=500, detail="Failed to save result")
    return SanProcessResponse(
        wellbeing=result['wellbeing'],
        activity=result['activity'],
        mood=result['mood'],
        timestamp=result['timestamp'],
        interpretation=result['interpretation']
    )


@app.post(
    '/api/test-results',
    response_model=SuccessResponse,
    responses={'400': {'model': Error}, '401': {'model': Error}},
    tags=['Тесты'],
)
def post_api_test_results(body: TestResultRequest, user_id: str = Depends(get_current_user_id)) -> Union[SuccessResponse, Error]:
    """
    Сохранение готового результата теста САН (альтернатива process)
    """
    # Преобразовать int в float
    wellbeing = float(body.wellbeingScore)
    activity = float(body.activityScore)
    mood = float(body.moodScore)
    success = san_service.save_result(user_id, wellbeing, activity, mood)
    if not success:
        raise HTTPException(status_code=500, detail="Failed to save result")
    return SuccessResponse(message="Test result saved")


@app.get(
    '/api/test-results',
    response_model=List[TestResult],
    responses={'401': {'model': Error}},
    tags=['Тесты'],
)
def get_api_test_results(
    limit: Optional[conint(ge=1, le=50)] = 5,
    user_id: str = Depends(get_current_user_id)
) -> Union[List[TestResult], Error]:
    """
    Получение последних результатов тестов
    """
    results = RealtimeDB.get(f'Users/{user_id}/TestResults')
    if not results:
        return []
    # Сортировка по timestamp, limit последних
    sorted_results = sorted(results.values(), key=lambda x: x.get('timestamp', 0), reverse=True)[:limit]
    test_results = []
    for res in sorted_results:
        test_results.append(TestResult(
            resultId=str(hash(str(res))),  # Pseudo ID
            userId=user_id,
            wellbeingScore=int(res.get('wellbeingScore', 0)),
            activityScore=int(res.get('activityScore', 0)),
            moodScore=int(res.get('moodScore', 0)),
            timestamp=datetime.fromtimestamp(res.get('timestamp', 0) / 1000) if res.get('timestamp') else None
        ))
    return test_results


@app.delete(
    '/api/test-results',
    response_model=SuccessResponse,
    responses={'401': {'model': Error}},
    tags=['Тесты'],
)
def delete_api_test_results(user_id: str = Depends(get_current_user_id)) -> Union[SuccessResponse, Error]:
    """
    Сброс всех результатов тестов
    """
    RealtimeDB.delete(f'Users/{user_id}/TestResults')
    return SuccessResponse(message="All test results deleted")


@app.put(
    '/api/users/change-email',
    response_model=SuccessResponse,
    responses={
        '400': {'model': Error},
        '401': {'model': Error},
        '409': {'model': Error},
    },
    tags=['Пользователи'],
)
def put_api_users_change_email(
    body: ChangeEmailRequest,
    user_id: str = Depends(get_current_user_id)
) -> Union[SuccessResponse, Error]:
    """
    Смена email пользователя
    """
    # Заглушка: Firebase Auth change email требует password verify, но сервис не имеет
    # В реальности: auth.update_user(user_id, email=body.newEmail)
    # Здесь просто update в DB
    RealtimeDB.update(f'Users/{user_id}', {'email': body.newEmail})
    return SuccessResponse(message="Email changed successfully")


@app.put(
    '/api/users/change-password',
    response_model=SuccessResponse,
    responses={'400': {'model': Error}, '401': {'model': Error}},
    tags=['Пользователи'],
)
def put_api_users_change_password(
    body: ChangePasswordRequest,
    user_id: str = Depends(get_current_user_id)
) -> Union[SuccessResponse, Error]:
    """
    Смена пароля пользователя
    """
    # Заглушка: Firebase Auth update_password, но требует current password verify
    # auth.update_user(user_id, password=body.newPassword)
    return SuccessResponse(message="Password changed successfully")


@app.get(
    '/api/users/profile',
    response_model=UserProfile,
    responses={'401': {'model': Error}},
    tags=['Пользователи'],
)
def get_api_users_profile(user_id: str = Depends(get_current_user_id)) -> Union[UserProfile, Error]:
    """
    Получение профиля пользователя
    """
    import logging
    logger = logging.getLogger(__name__)
    profile = RealtimeDB.get(f'Users/{user_id}')
    logger.info(f"DB query for user_id {user_id}: {profile}")
    if not profile:
        raise HTTPException(status_code=404, detail="Profile not found")
    return UserProfile(
        userId=user_id,
        email=profile.get('email'),
        username=profile.get('username'),
        createdAt=datetime.fromisoformat(profile.get('createdAt')) if profile.get('createdAt') else None,
        updatedAt=datetime.now()  # Pseudo
    )


@app.put(
    '/api/users/profile',
    response_model=UserProfile,
    responses={'400': {'model': Error}, '401': {'model': Error}},
    tags=['Пользователи'],
)
def put_api_users_profile(body: UpdateProfileRequest, user_id: str = Depends(get_current_user_id)) -> Union[UserProfile, Error]:
    """
    Обновление профиля пользователя
    """
    if body.username:
        RealtimeDB.update(f'Users/{user_id}', {'username': body.username, 'updatedAt': datetime.now().isoformat()})
    # Fetch updated
    profile = RealtimeDB.get(f'Users/{user_id}')
    return UserProfile(
        userId=user_id,
        email=profile.get('email'),
        username=profile.get('username'),
        createdAt=datetime.fromisoformat(profile.get('createdAt')) if profile.get('createdAt') else None,
        updatedAt=datetime.fromisoformat(profile.get('updatedAt')) if profile.get('updatedAt') else None
    )
